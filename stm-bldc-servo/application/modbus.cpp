/*
 * modbus.cpp
 *
 *  Created on: Feb 4, 2022
 *	  Author: cchtofl01
 */




#include "modbus.h"
#include "main.h"
#include "serial.h"
#include "crc16.h"
#include "string.h"
#include "main.h"
#include "stdlib.h"
#include "stm32_hal.h"
#include "autogenerated_modbus.h"



extern UART_HandleTypeDef huart1;
extern const Database_declaration_t database_declaration;
extern Database_value_t database_value;


enum {
	MODBUS_MAX_MESSAGE_LENGTH = 256,
	MODBUS_TIMEOUT_BITS = 28,
	INDEX_ADDRESS = 0,
	INDEX_FUNCTION = 1,
	INDEX_DATA = 2
};

//array access macros
#define read_array_16_bit_be(array, index)           ((array[(index)] << 8) + array[(index)+1])		 //big endian version
#define read_array_16_bit_le(array, index)           (array[(index)] + (array[(index)+1] << 8))		 //little endian version
#define read_array_8_bit(array, index)               (array[(index)])
#define write_array_16_bit_be(array, index, value)   {array[(index)] = ((value) & 0xFF00) >> 8; array[(index)+1] = (value) & 0x00FF;}   //big endian version
#define write_array_16_bit_le(array, index, value)   {array[(index)] = (value) & 0x00FF; array[(index)+1] = ((value) & 0xFF00) >> 8;}   //little endian version
#define write_array_8_bit(array, index, value)       {array[(index)] = (value);}

#define check_index_boundary(serial, messageBuffer, index, max)         if ((index) > (max)) { error_response(serial, messageBuffer, EXC_PROCESSING); return; }




typedef enum {
	FN_READ_DISCRETE_INPUTS= 2,
	FN_READ_COILS = 1,
	FN_WRITE_SINGLE_COIL = 5,
	FN_WRITE_MULTIPLE_COILS = 15,
	FN_READ_HOLDING_REGISTER = 3,
	FN_READ_INPUT_REGISTER = 4,
	FN_WRITE_SINGLE_REGISTER = 6,
	FN_WRITE_MULTIPLE_REGISTER = 16,
	FN_READ_WRITE_MULTIPLE_REGISTER = 23,
	FN_MASK_WRITE_REGISTER = 22,
	FN_READ_FIFO_QUEUE = 24,
	FN_READ_FILE_RECORD = 20,
	FN_WRITE_FILE_RECORD = 21,
	FN_READ_EXCEPTION_STATUS = 7,
	FN_DIAGNOSTIC = 8,
	FN_GET_COM_EVENT_COUNTER = 11,
	FN_GET_COM_EVENT_LOG = 12,
	FN_REPORT_SLAVE_ID = 17,
	FN_READ_DEVICE_IDENTIFICATION = 43
} ModbusFunction_en;

typedef enum {
	EXC_NONE = 0,
	EXC_FUNCTION = 1,
	EXC_QUANTITY = 3,
	EXC_ADDRESS = 2,
	EXC_PROCESSING = 4,
	EXC_CRC = 100
} ModbusException_en;



static uint8_t own_address = 1;

static void error_response(Serial& serial, uint8_t* messageBuffer, ModbusException_en exception);

static int16_t database_get_parameter(uint16_t parameter_id);
static void database_write_parameter(uint16_t parameter_id, int16_t value);
static uint32_t database_write_parameter_external(uint16_t parameter_id, int16_t value);
static uint16_t database_get_parameter_id_from_modbus(uint16_t modbus_address);
static uint32_t database_is_readable_external(uint16_t parameter_id);


void modbus_init_slave(uint8_t deviceaddress) {
	own_address = deviceaddress;
}


void modbus_process_data_slave(Serial& serial, uint8_t* messageBuffer, uint32_t len) {
	uint8_t address = messageBuffer[INDEX_ADDRESS];
	ModbusFunction_en function = (ModbusFunction_en)messageBuffer[INDEX_FUNCTION];

	if (address != own_address) {
		return; //does not belong to this node
	}

	switch (function) {

		case FN_READ_INPUT_REGISTER:
		case FN_READ_HOLDING_REGISTER: {
			//read request contents
			uint32_t start_address = read_array_16_bit_be(messageBuffer, 2);
			uint32_t quantity = read_array_16_bit_be(messageBuffer, 4);

			//calculate and handle crc
			uint16_t crc_message = read_array_16_bit_le(messageBuffer, 6);
			uint16_t crc_calculated = calculate_CRC16(messageBuffer, 6);
			if (crc_message != crc_calculated) {
				error_response(serial, messageBuffer, EXC_CRC);
				return;
			}

			//write response. address and function are already in buffer
			write_array_8_bit(messageBuffer, 2, quantity * 2);  //length
			//write data part of response
			for (uint32_t i = 0; i < quantity; i++) {
				uint16_t id = database_get_parameter_id_from_modbus(start_address+i); // Read index for each Modbus address

				if (id == 65535) {
					error_response(serial, messageBuffer, EXC_PROCESSING);
					return;
				}
				//check each value for access violation
				//if one detected, exit with an error.

				if (!database_is_readable_external(id)) {
					error_response(serial, messageBuffer, EXC_PROCESSING);
					return;
				}
				//read the values (for real this time)
				//no longer needed to use the save read function because everything has been checked

				uint16_t value = database_get_parameter(id);
				write_array_16_bit_be(messageBuffer, 3 + i * 2, value);
			}

			// Check if respond message will be too long. If so macro returns here.
			// In response: Message length = 3 bytes + (2 bytes for data * quantity) + 2 bytes for CRC
			// (Standard response = Address, Function code and Bytes count (2 * quantity) + CRC
			// Quantity = number of indexes requested. (Handles also multiple read message)
			check_index_boundary(serial, messageBuffer, 3 + 2 * quantity + 2, MODBUS_MAX_MESSAGE_LENGTH-1);
			//append crc and send
			crc_calculated = calculate_CRC16(messageBuffer, 3 + 2 * quantity);
			write_array_16_bit_le(messageBuffer, 3 + 2 * quantity, crc_calculated);
			serial.writeBuf(messageBuffer, 3 + 2 * quantity + 2);
		}
		break;


		case FN_WRITE_SINGLE_REGISTER: {
			//read request contents
			uint32_t address = read_array_16_bit_be(messageBuffer, 2);
			uint16_t value = read_array_16_bit_be(messageBuffer, 4);

			//calculate and handle crc
			uint16_t crc_message = read_array_16_bit_le(messageBuffer, 6);
			uint16_t crc_calculated = calculate_CRC16(messageBuffer, 6);
			if (crc_message != crc_calculated) {
				error_response(serial, messageBuffer, EXC_CRC);
				return;
			}

			//write response. address is already in buffer
			//the rest also is already in buffer
			if (database_write_parameter_external(database_get_parameter_id_from_modbus(address), value)) {
				error_response(serial, messageBuffer, EXC_PROCESSING);
				return;
			}

			//append crc and send
			//crc is already in buffer
			serial.writeBuf(messageBuffer, 6 + 2); // Message + CRC
		}
		break;

		case FN_WRITE_MULTIPLE_REGISTER: {
			uint32_t start_address = read_array_16_bit_be(messageBuffer, 2);
			uint32_t quantity = read_array_16_bit_be(messageBuffer, 4);
			//uint32_t byte_count = read_array_8_bit(messageBuffer, 6);

			// Check if respond message will be too long. If so macro returns here.
			// In response: Message length = 5 bytes + (2 bytes for data * quantity) + 2 bytes for CRC
			// (Response = Address, Function code, Starting Address(2 bytes) and Quantity of Registers(2 bytes each) + CRC
			// Quantity = number of indexes to write.
			check_index_boundary(serial, messageBuffer, 5 + 2 * quantity + 2, MODBUS_MAX_MESSAGE_LENGTH - 1);
			//calculate and handle crc
			uint16_t crc_message = read_array_16_bit_le(messageBuffer, 7 + 2 * quantity);
			uint16_t crc_calculated = calculate_CRC16(messageBuffer, 7 + 2 * quantity);
			if (crc_message != crc_calculated) {
				error_response(serial, messageBuffer, EXC_CRC);
				return;
			}

			//write response. address and function are already in buffer
			//the rest also is already in buffer
			for (uint32_t i = 0; i < quantity; i++) {
				uint16_t id = database_get_parameter_id_from_modbus(start_address + i); // Read index for each Modbus address
				if (id == 65535) {
					error_response(serial, messageBuffer, EXC_PROCESSING);
					return;
				}
				uint16_t value = read_array_16_bit_be(messageBuffer, 7 + 2 * i);
				if (database_write_parameter_external(id, value)) {
					error_response(serial, messageBuffer, EXC_PROCESSING);
					return;
				}
			}

			//append crc and send
			crc_calculated = calculate_CRC16(messageBuffer, 6);
			write_array_16_bit_le(messageBuffer, 6, crc_calculated);
			serial.writeBuf(messageBuffer, 6 + 2);
		}
		break;

		case FN_READ_WRITE_MULTIPLE_REGISTER: {
			uint32_t start_address_read = read_array_16_bit_be(messageBuffer, 2);
			uint32_t quantity_read = read_array_16_bit_be(messageBuffer, 4);
			uint32_t start_address_write = read_array_16_bit_be(messageBuffer, 6);
			uint32_t quantity_write = read_array_16_bit_be(messageBuffer, 8);

			// Check if respond message will be too long. If so macro returns here.
			// In response: Message length = 4 bytes + (2 bytes for data * quantity) + 2 bytes for CRC
			// (Response = Address, Function code, Starting Address(2 bytes) and Quantity of Registers(2 bytes each) + CRC
			// Quantity = number of indexes to write.
			check_index_boundary(serial, messageBuffer, 3 + 2 * quantity_read, MODBUS_MAX_MESSAGE_LENGTH - 1);

			//calculate and handle crc
			uint16_t crc_message = read_array_16_bit_le(messageBuffer, 11 + 2 * quantity_write);
			uint16_t crc_calculated = calculate_CRC16(messageBuffer, 11 + 2 * quantity_write);
			if (crc_message != crc_calculated) {
				error_response(serial, messageBuffer, EXC_CRC);
				return;
			}

			//read request and write data in out own registers
			for (uint32_t i = 0; i < quantity_write; i++) {
				uint16_t id = database_get_parameter_id_from_modbus(start_address_write + i); // Read index for each Modbus address
				if (id == 65535) {
					error_response(serial, messageBuffer, EXC_PROCESSING);
					return;
				}
				uint16_t value = read_array_16_bit_be(messageBuffer, 11 + 2 * i);
				if (database_write_parameter_external(id, value)) {
					error_response(serial, messageBuffer, EXC_PROCESSING);
					return;
				}
			}

			//write response. address and function are already in buffer
			write_array_8_bit(messageBuffer, 2, quantity_read * 2);  //length
			//write data part of response
			for (uint32_t i = 0; i < quantity_read; i++) {
				uint16_t id = database_get_parameter_id_from_modbus(start_address_read+i); // Read index for each Modbus address

				if (id == 65535) {
					error_response(serial, messageBuffer, EXC_PROCESSING);
					return;
				}

				//check each value for access violation
				//if one detected, exit with an error.
				if (!database_is_readable_external(id)) {
					error_response(serial, messageBuffer, EXC_PROCESSING);
					return;
				}

				//read the values (for real this time)
				//no longer needed to use the save read function because everything has been checked
				uint16_t value = database_get_parameter(id);
				write_array_16_bit_be(messageBuffer, 3 + i * 2, value);
			}

			//append crc and send
			crc_calculated = calculate_CRC16(messageBuffer, 3 + 2 * quantity_read);
			write_array_16_bit_le(messageBuffer, 3 + 2 * quantity_read, crc_calculated);
			serial.writeBuf(messageBuffer, 3 + 2 * quantity_read + 2);
			//
		}
		break;

		case FN_READ_DEVICE_IDENTIFICATION:
		case FN_READ_DISCRETE_INPUTS:
		case FN_READ_COILS:
		case FN_WRITE_SINGLE_COIL:
		case FN_WRITE_MULTIPLE_COILS:
		case FN_MASK_WRITE_REGISTER:
		case FN_READ_FIFO_QUEUE:
		case FN_READ_FILE_RECORD:
		case FN_WRITE_FILE_RECORD:
		case FN_READ_EXCEPTION_STATUS:
		case FN_DIAGNOSTIC:
		case FN_GET_COM_EVENT_COUNTER:
		case FN_GET_COM_EVENT_LOG:
		case FN_REPORT_SLAVE_ID:
		default:
			error_response(serial, messageBuffer, EXC_FUNCTION);
			return;
	}
}



static void error_response(Serial& serial, uint8_t* messageBuffer, ModbusException_en exception) {
	if (exception == EXC_CRC) {
		return; //return no exception on crc error
	} else {
		messageBuffer[INDEX_FUNCTION] = messageBuffer[INDEX_FUNCTION] + 0x80; //make an error out of it
		messageBuffer[INDEX_DATA] = (uint8_t)exception; //make an error out of it
		uint32_t crc_calculated = calculate_CRC16(messageBuffer, 3);
		write_array_16_bit_le(messageBuffer, 3, crc_calculated);
		serial.writeBuf(messageBuffer, 3 + 2);
	}
}

/**
 * Read a parameter value from Modbus registers
 */
static int16_t database_get_parameter(uint16_t parameter_id) {
	const uint16_t* values = (uint16_t*)&database_value;
	return values[parameter_id];
}

/**
 * Write a parameter value to Modbus registers.
 */
static void database_write_parameter(uint16_t parameter_id, int16_t value) {
	uint16_t* values = (uint16_t*)&database_value;
	values[parameter_id] = value;
}

/**
 * Write a parameter value to Modbus registers.
 * returns 1 on error
 */
static uint32_t database_write_parameter_external(uint16_t parameter_id, int16_t value) {
	database_write_parameter(parameter_id, value);
	return 0;
}

/**
 * Reverse lookup Modbus Address to Parameter ID
 * Returns -1 if Modbus Address does not exist
 */
static uint16_t database_get_parameter_id_from_modbus(uint16_t modbus_address) {
	const Database_limit_t* declarations = (Database_limit_t*)&database_declaration;
	for (uint32_t i = 0; i < DATABASE_LENGTH; i++) {
		if (declarations[i].address == modbus_address) {
			return i;
		}
	}
	return -1;
}

/**
 * return 1 if writeable
 */
static uint32_t database_is_readable_external(uint16_t parameter_id) {
	return 1;
}


