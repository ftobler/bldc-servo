/*
 * application.cpp
 *
 *  Created on: Apr 17, 2024
 *      Author: ftobler
 */


#include "stm32_hal.h"
#include "application.h"
#include "main.h"
#include "flortos.h"
#include "autogenerated_modbus.h"

enum {
	N = 256,

	PWM_MID = 1600,
	AMP_MAX = 1550,
};

extern ADC_HandleTypeDef hadc1;
extern DMA_HandleTypeDef hdma_adc1;
extern TIM_HandleTypeDef htim3;

//volatile int32_t angle_target = 0;
volatile int32_t controlsignal = 0;

uint32_t adc_dma_results[1];

volatile uint32_t perf_loop = 0;



static volatile int32_t integrator = 0;
//static volatile int32_t integrator_max = 5000;
//static volatile int32_t controller_p = 12;
//static volatile int32_t controller_i = 60;
static volatile int32_t error_trace = 0;
static volatile float angle_target_smooth = 0;
//static volatile float acceleration = 0.01f;
static volatile float velocity = 0.0f;
//static volatile float velocity_max = 0.18f;

extern int32_t as5600_angle;
extern Database_value_t database_value;


void application_setup() {

	HAL_TIM_Base_Start_IT(&htim3);
	HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);
	HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_2);
	HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_3);

	htim3.Instance->CCR1 = PWM_MID;
	htim3.Instance->CCR2 = PWM_MID;
	htim3.Instance->CCR3 = PWM_MID;

	HAL_ADC_Start_DMA(&hadc1, adc_dma_results, 1);

	scheduler_task_sleep(300); //wait for power to be more stable

	//switch SKIP pin, this will enable the drivers from Diode mode to PWM mode
	SKIP_GPIO_Port->BSRR = SKIP_Pin;
	angle_target_smooth = as5600_angle;
}

__attribute__((optimize("Ofast"))) void application_loop() {
	perf_loop++;

	uint16_t sens1 = GPIOA->IDR & SENS1_Pin;
	uint16_t sens2 = GPIOA->IDR & SENS2_Pin;
	uint16_t sens3 = GPIOA->IDR & SENS3_Pin;

	int32_t commutation = 0;
	if (sens1==0 && sens2==0 && sens3   ) commutation = 0;
	if (sens1==0 && sens2    && sens3   ) commutation = 1;
	if (sens1==0 && sens2    && sens3==0) commutation = 2;
	if (sens1    && sens2    && sens3==0) commutation = 3;
	if (sens1    && sens2==0 && sens3==0) commutation = 4;
	if (sens1    && sens2==0 && sens3   ) commutation = 5;
	commutation = -commutation;

	int32_t block = 0;
	if (controlsignal > 0) {
		block = -controlsignal;
		commutation = (commutation + 10) % 6; //forward
	} else {
		block = controlsignal;
	    commutation = (commutation + 7) % 6; //reverse
	}
	database_value.pwm = block;
	int max_pwm = database_value.maxpwm;
	if (max_pwm > AMP_MAX) {
		max_pwm = AMP_MAX;
	}
	if (block > max_pwm) {
		block = max_pwm;
	}
	if (block < -max_pwm) {
		block = -max_pwm;
	}

	uint32_t ccr1 = 0;
	uint32_t ccr2 = 0;
	uint32_t ccr3 = 0;
	if (database_value.mode) { // off
		switch (commutation) {
		case 0:
			ccr1 = PWM_MID + 0;
			ccr2 = PWM_MID - block;
			ccr3 = PWM_MID + block;
			break;
		case 1:
			ccr1 = PWM_MID + block;
			ccr2 = PWM_MID - block;
			ccr3 = PWM_MID + 0;
			break;
		case 2:
			ccr1 = PWM_MID + block;
			ccr2 = PWM_MID + 0;
			ccr3 = PWM_MID - block;
			break;
		case 3:
			ccr1 = PWM_MID + 0;
			ccr2 = PWM_MID + block;
			ccr3 = PWM_MID - block;
			break;
		case 4:
			ccr1 = PWM_MID - block;
			ccr2 = PWM_MID + block;
			ccr3 = PWM_MID + 0;
			break;
		case 5:
			ccr1 = PWM_MID - block;
			ccr2 = PWM_MID + 0;
			ccr3 = PWM_MID + block;
			break;
		}
	}

	htim3.Instance->CCR1 = ccr1;
	htim3.Instance->CCR2 = ccr2;
	htim3.Instance->CCR3 = ccr3;

	database_value.commutation = commutation;
	database_value.pwm = controlsignal;
}


__attribute__((optimize("Ofast"))) void control_loop() {
	//calculate the distance to target position
	int32_t angle_target = (int16_t)database_value.target;
	float disttogo = angle_target - angle_target_smooth;

	float acceleration = database_value.acceleration / 1000000.0f;
	float velocity_max = database_value.speedmax / 1000.0f;


	int32_t integrator_max = database_value.i_windup * 1000;
	int32_t controller_p = database_value.control_p;
	int32_t controller_i = database_value.control_i;

	//calculate the maximum velocity for distance to target. We don't want to be
	//faster or braking will become an issue.
	//Make this square to not need to calculate squareroot.
	float max_velocity_sq = (2 * acceleration * disttogo);

	//need to decide from which direction we make our ramps
	if (max_velocity_sq >= 0) {
		//forward direction
		if (max_velocity_sq >= velocity*velocity) {
			//accelerate
			if (velocity < velocity_max) {
				velocity += acceleration;
			}
		} else {
			//de-accelerate
			if (velocity > 0) {
				velocity -= acceleration;
			} else {
				velocity = 0;
			}
	    }
	} else {
		//backward direction
		if (-max_velocity_sq >= velocity*velocity) {
			//accelerate (reverse direction)
			if (velocity > -velocity_max) {
				velocity -= acceleration;
			}
		} else {
			//de-accelerate (reverse direction)
			if (velocity < 0) {
				velocity += acceleration;
			} else {
				velocity = 0;
			}
		}
	}
	angle_target_smooth += velocity;


	int32_t error = angle_target_smooth - as5600_angle;
	integrator += error;
	if (integrator > integrator_max) {
		integrator = integrator_max;
	}
	if (integrator < -integrator_max) {
		integrator = -integrator_max;
	}

	controlsignal  = error * controller_p + integrator * controller_i / 2048;


	error_trace = (error_trace +  error * error) * 255 / 256;


	database_value.error = error;
	database_value.position = as5600_angle;
	database_value.speed = velocity;
}
